---
title: 'Notes: How to GraphQL Course'
blurb: My thoughts and notes while going through the How to GraphQL course with my Party Corgi adventure club!
tags:
  - garden
  - GraphQL
type: notes
featured: false
---

## Introduction

GraphQL (gql): a new API standard, meant to be a more efficient & flexible alternative to REST.

Gql enables declarative data fetching & exposes single endpoint in response to queries. It's meant to be a way for a client to ask specifically for the data it needs, and get that information back on one endpoint instead of a number of different requests.

An API is a way for client devices to get & load data from a server.

**Gql is a query language, not a database! It's db agnostic & can be used effectively with any API context.**

3 factors that impact how API's are designed in today's landscape:

- *Increased mobile usage.* Gql minimizes the amount of data that needs to be transferred, making it more efficient
- *Front end framework variety.* It's difficult to make API's fit requirements of so many different options - gql helps
- *Fast development.* Continuous deployment & rapid iterations can get tricky with REST options

Gql isn't just for react - can be used with any language or framework!

----

## GraphQL is the better REST

REST was a good start w/ some solid ideas like stateless servers and structured access to resources. But it's a rigid system, and is often misconstrued and not used in the way it was designed. So gql is meant to be a new methodology, built for flexibility and efficiency.

Main difference point - with REST you're making multiple requests, and getting all the info in each request instead of only the data you want from each call. Can modify the API to match your designs, but would then add extra work when your design changes or you need other information, having to update both the front code & the server.

With gql, you only need to send 1 request (not multiple), and specify exactly which data you want, with limits/specific query options. When you've got changes in design, you only need to modify your query request, not the actual API.

gql also has it's own schema system, which acts as a contract between server & client - once it's set, it's easier for both sides of developers to work on their own.

gql also has the ability to monitor performance & requested queries, so you can see if certain data fields aren't being used anymore, and can notice bottlenecks or issues with your structure.

----

## Core Concepts

The Schema Definition Language (SDL)

Basic example:

```js
type Person {
  id: ID! // unique id generated by server
  name: String!
  age: Int!
}
```

This defines the name of the object, as well as the possible fields and what type of data those fields are. The `!` means the field is required.

If we want to add a relation between two types, we can do that like this:

```js
type Post {
  title: String!
  author: Person!
}

type Person {
  name: String!
  age: Int!
  posts: [Post!]!
}
```

This makes each post tied to a specific person, and then in the `Person` type, we have a list `[]` of posts, which will show the name of any posts the person is tied to as the author.

The structure of the data returned from gql is **not** fixed. A gql database usually only exposes one endpoint. So we can fetch data using queries, which we can adjust to match whatever data we need.

```js
{
  allPersons { // root field
    name // payload
  }
}

// can also add arguments to request
{
   allPersons(last: 2) {
     name
   }
}

// can get nested information
{
  allPersons {
    name
    posts { // this was our array field
      title
    }
  }
}
```

When we need to make changes to the data, we do so with **mutations**. Generally follow same structure as requests, but have the word mutation first.

Gql has 3 kinds:

- creating new data
- updating existing data
- deleting existing data

```js
mutation { // saying we want to change something
  createPerson(name: 'Bob', age: 36) { // root
    id // can also request payload with mutations. So if we had an id field on our Person, we can add a new Person and get the unique id back as a request
  }
}
```

If we need real time updates when something on the server changes, we can **subscribe** to certain events. When that's done, it gets a steady connection to the server, and when new info comes in, it automatically sends that new data to the client. Subscriptions work as a stream of information, rather than request/response cycle.

```js
subscription {
  newPerson {
    name
    age
  }
}
```

### The GraphQL Schema

The schema defines capabilities of the API by specifying how a client can fetch and update data. It's a collection of gql types with special root types.

```js
type Query {
  allPersons(last: Int): [Person!]! // allows last parameter, and lists type of what the query will return
}

type Mutation {
  createPerson(name: String!, age: String!): Person! // takes in arguments we want to add for mutation, and returns a single Person object
}

type Subscription {
  newPerson: Person! // shows that when subscribed, this is the type of object we're watching for
}
```

----

## Big Picture

Gql is actually only a *specification* - just a long document how a gql server should behave. You have to build the server yourself if you want to use it.

3 possible setups:

- server w/ connected database
- server that integrates with existing system
- hybrid - connected database and integration into existing system

1. server with connected db
  uses a single web server that implements gql
  server resolves queries and constructs responses with data it fetches from the db
  transport layer agnostic - can use any language of construct
  could also use any type of db you'd like

2. server w/ existing system
  great for companies with legacy systems and lots of different APIs
  gql can unify existing systems and hide complexity of the data fetching logic, providing a nice single endpoint
  server doesn't care about where the data sources are

3. hybrid approach
  combines both options, so when a query is received, it will either fetch the data from the connected systems, or resolve it from the connected db and then send back the data

**resolver** functions - retrieves data for it's corresponding field - gql server has exactly one resolver function per field.

Resolvers can take either provided arguments or implicit arguments, depending on what data it needs to get it's response.

![Resolver functions with an example](https://i.imgur.com/e1gBEP5.png)

gql is great for front end, as data fetching can be pushed to server side. Don't need to care where data is coming from, so logic can be abstracted away.

Storage of data, request specifics, and all other steps besides describing the data you want and displaying it is handled by the gql server. This is called declarative data fetching. Imperative data fetching is the full process of constructing the HTTP request, parsing the response, storing the data, and then displaying it. Lots of gql client libraries exist to allow you to use declarative fetching and focus on the data itself.
